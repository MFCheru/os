\section{Round Robin Implementation}

\subsection{Código}

En primer lugar, modificamos la declaracion de la clase  \texttt{SchedRR} agregando una serie de atributos privados:

\subsubsection{Class Declaration}
\begin{lstlisting}[language=C++, breaklines=true]
class SchedRR : public SchedBase {
	public:
		SchedRR(std::vector<int> argn);
        ~SchedRR();
		virtual void load(int pid);
		virtual void unblock(int pid);
		virtual int tick(int cpu, const enum Motivo m);

	private:
		int quantum;
		int* cycles;
		std::queue<int> q;
};
\end{lstlisting}

Por un lado, el \texttt{quantum}, que nos dice por cuantos ciclos de clock nuestras tareas se van a ejecutar. Por otro lado, tenemos un puntero de enteros llamado \texttt{cycles}, que lo que hace es mantener la cuenta de cuantos ciclos le quedan a cada tarea en ejecución por CPU antes de llegar al quantum. Finalmente, tenemos una cola de tareas \texttt{q} compartida entre CPUs.

\subsubsection{Constructor}
\begin{lstlisting}[language=C++, breaklines=true]
SchedRR::SchedRR(vector<int> argn) {
	// Round robin recibe la cantidad de cores y sus cpu_quantum por parametro

	quantum = argn[1];
	cycles = new int[argn[0]];
	fill_n(cycles, argn[0], quantum); 
}
\end{lstlisting}

\subsubsection{Destructor}
\begin{lstlisting}[language=C++, breaklines=true]
SchedRR::~SchedRR() {
	delete[] cycles;
}
\end{lstlisting}

\pagebreak

\subsubsection{Tick}
\begin{lstlisting}[language=C++, breaklines=true]
int SchedRR::tick(int cpu, const enum Motivo m) {
	if (m == EXIT) {
		// Si el pid actual termino, sigue el proximo.
		if (q.empty()) return IDLE_TASK;
		else {
			int sig = q.front(); q.pop();
			cycles[cpu] = quantum;
			return sig;
		}
	} else {
		if (current_pid(cpu) == IDLE_TASK && !q.empty()) {
			int sig = q.front(); q.pop();
			cycles[cpu] = quantum;
			return sig;
		} else {
			cycles[cpu]--;

			if (cycles[cpu] == 0) {
				if (q.empty()) {
					cycles[cpu] = quantum;
					return current_pid(cpu);
				} else {
					int sig = q.front(); q.pop();
					q.push(current_pid(cpu)); // re-add to queue
					cycles[cpu] = quantum;
					return sig;
				}
			} else {
				return current_pid(cpu);
			}
		}
	}
}
\end{lstlisting}




