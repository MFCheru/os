\section{Round Robin 2}

\subsection{Codigo}

\subsubsection{Class Declaration}
\begin{lstlisting}[language=C++, breaklines=true]
class SchedRR2 : public SchedBase {
	public:
		SchedRR2(std::vector<int> argn);
        ~SchedRR2();
		virtual void load(int pid);
		virtual void unblock(int pid);
		virtual int tick(int cpu, const enum Motivo m);
	private:
		int quantum;
		int* cycles;
		std::vector<std::queue<int> > q;
		std::vector<int> totalLoad; // buscar otra estructura?

		int getCPU();
};
\end{lstlisting}

\subsubsection{Constructor}
\begin{lstlisting}[language=C++, breaklines=true]
SchedRR2::SchedRR2(vector<int> argn) {
	// Round robin recibe la cantidad de cores y sus cpu_quantum por parametro
	for (int i = 0; i < argn[0]; ++i) {
		q.push_back(queue<int>());
		totalLoad.push_back(0);
	}

	quantum = argn[1];
	cycles = new int[argn[0]];
	fill_n(cycles, argn[0], quantum);
}
\end{lstlisting}

\subsubsection{Desctructor}
\begin{lstlisting}[language=C++, breaklines=true]
SchedRR2::~SchedRR2() {
	delete[] cycles;
}
\end{lstlisting}

\subsubsection{Load}
\begin{lstlisting}[language=C++, breaklines=true]
void SchedRR2::load(int pid) {
	int cpu = getCPU();
	q.at(cpu).push(pid);
	totalLoad[cpu]++;
}
\end{lstlisting}

\subsubsection{tick}
\begin{lstlisting}[language=C++, breaklines=true]
int SchedRR2::tick(int cpu, const enum Motivo m) {
	if (m == EXIT) {
		totalLoad[cpu]--;
		// Si el pid actual termino, sigue el proximo.
		if (q.at(cpu).empty()) return IDLE_TASK;
		else {
			int sig = q.at(cpu).front(); q.at(cpu).pop();
			cycles[cpu] = quantum;
			return sig;
		}
	} else {
		if (current_pid(cpu) == IDLE_TASK && !q.at(cpu).empty()) {
			int sig = q.at(cpu).front(); q.at(cpu).pop();
			cycles[cpu] = quantum;
			return sig;
		} else {
			cycles[cpu]--;

			if (cycles[cpu] == 0) {
				if (q.at(cpu).empty()) {
					cycles[cpu] = quantum;
					return current_pid(cpu);
				} else {
					int sig = q.at(cpu).front(); q.at(cpu).pop();
					q.at(cpu).push(current_pid(cpu)); // re-add to queue
					cycles[cpu] = quantum;
					return sig;
				}
			} else {
				return current_pid(cpu);
			}
		}
	}
}
\end{lstlisting}

\subsubsection{getCPU}
\begin{lstlisting}[language=C++, breaklines=true]
int SchedRR2::getCPU() {
	int cpu = 0;
	int i = 1;
	for (vector<int>::iterator it = ++totalLoad.begin() ; it != totalLoad.end(); ++it) {
		if (*it < totalLoad.at(cpu)) {
			cpu = i;
		}
		i++;
	}
	return cpu;
}
\end{lstlisting}